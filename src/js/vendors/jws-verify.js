(()=>{"use strict";class e extends Error{constructor(t){super(t),this.code=e.code,this.name=this.constructor.name,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}}e.code="ERR_JOSE_GENERIC";class t extends e{constructor(e,r="unspecified",a="unspecified"){super(e),this.code=t.code,this.claim=r,this.reason=a}}t.code="ERR_JWT_CLAIM_VALIDATION_FAILED";class r extends e{constructor(){super(...arguments),this.code=r.code}}r.code="ERR_JOSE_ALG_NOT_ALLOWED";class a extends e{constructor(){super(...arguments),this.code=a.code}}a.code="ERR_JOSE_NOT_SUPPORTED";class n extends e{constructor(){super(...arguments),this.code=n.code,this.message="decryption operation failed"}}n.code="ERR_JWE_DECRYPTION_FAILED";class o extends e{constructor(){super(...arguments),this.code=o.code}}o.code="ERR_JWE_INVALID";class s extends e{constructor(){super(...arguments),this.code=s.code}}s.code="ERR_JWS_INVALID";class c extends e{constructor(){super(...arguments),this.code=c.code}}c.code="ERR_JWT_INVALID";class i extends e{constructor(){super(...arguments),this.code=i.code}}i.code="ERR_JWK_INVALID";class d extends e{constructor(){super(...arguments),this.code=d.code}}d.code="ERR_JWKS_INVALID";class l extends e{constructor(){super(...arguments),this.code=l.code,this.message="no applicable key found in the JSON Web Key Set"}}l.code="ERR_JWKS_NO_MATCHING_KEY";class u extends e{constructor(){super(...arguments),this.code=u.code,this.message="multiple matching keys found in the JSON Web Key Set"}}u.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";class h extends e{constructor(){super(...arguments),this.code=h.code,this.message="signature verification failed"}}h.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";class p extends t{constructor(){super(...arguments),this.code=p.code}}p.code="ERR_JWT_EXPIRED";const y=new TextEncoder,S=new TextDecoder;function f(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const m=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;throw new Error("unable to locate global object")}(),w=e=>{let t=e;t instanceof Uint8Array&&(t=S.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return new Uint8Array(m.atob(t).split("").map((e=>e.charCodeAt(0))))}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}},A=m.crypto;const g=async(e,t,r,n)=>{const o=await function(e,t,r){if(function(e){return void 0!==m.CryptoKey&&null!=e&&e instanceof m.CryptoKey}(t))return t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError("symmetric keys are only applicable for HMAC-based algorithms");return A.subtle.importKey("raw",t,{hash:{name:`SHA-${e.substr(-3)}`},name:"HMAC"},!1,[r])}throw new TypeError("invalid key input")}(e,t,"verify");((e,t)=>{if(e.startsWith("HS")){const r=parseInt(e.substr(-3),10),{length:a}=t.algorithm;if("number"!=typeof a||a<r)throw new TypeError(`${e} requires symmetric keys to be ${r} bits or larger`)}if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}})(e,o);const s=function(e){switch(e){case"HS256":return{hash:{name:"SHA-256"},name:"HMAC"};case"HS384":return{hash:{name:"SHA-384"},name:"HMAC"};case"HS512":return{hash:{name:"SHA-512"},name:"HMAC"};case"PS256":return{hash:{name:"SHA-256"},name:"RSA-PSS",saltLength:32};case"PS384":return{hash:{name:"SHA-384"},name:"RSA-PSS",saltLength:48};case"PS512":return{hash:{name:"SHA-512"},name:"RSA-PSS",saltLength:64};case"RS256":return{hash:{name:"SHA-256"},name:"RSASSA-PKCS1-v1_5"};case"RS384":return{hash:{name:"SHA-384"},name:"RSASSA-PKCS1-v1_5"};case"RS512":return{hash:{name:"SHA-512"},name:"RSASSA-PKCS1-v1_5"};case"ES256":return{hash:{name:"SHA-256"},name:"ECDSA",namedCurve:"P-256"};case"ES384":return{hash:{name:"SHA-384"},name:"ECDSA",namedCurve:"P-384"};case"ES512":return{hash:{name:"SHA-512"},name:"ECDSA",namedCurve:"P-521"};default:throw new a(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}(e);try{return await A.subtle.verify(s,o,r,n)}catch(e){return!1}},E=function(e,t,r,n,o){if(void 0!==o.crit&&void 0===n.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let s;s=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of n.crit){if(!s.has(t))throw new a(`Extension Header Parameter "${t}" is not recognized`);if(void 0===o[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(s.get(t)&&void 0===n[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(n.crit)}.bind(void 0,s,new Map([["b64",!0]])),b=((e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)}).bind(void 0,"algorithms"),v=async function(e,t,a){var n;if(!f(e))throw new s("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new s('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new s("JWS Protected Header incorrect type");if(void 0===e.payload)throw new s("JWS Payload missing");if("string"!=typeof e.signature)throw new s("JWS Signature missing or incorrect type");if(void 0!==e.header&&!f(e.header))throw new s("JWS Unprotected Header incorrect type");let o={};if(e.protected){const t=w(e.protected);o=JSON.parse(S.decode(t))}if(!((...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0})(o,e.header))throw new s("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const c={...o,...e.header};let i=!0;if(E(null==a?void 0:a.crit,o,c).has("b64")&&(i=o.b64,"boolean"!=typeof i))throw new s('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:d}=c;if("string"!=typeof d||!d)throw new s('JWS "alg" (Algorithm) Header Parameter missing or invalid');const l=a&&b(a.algorithms);if(l&&!l.has(d))throw new r('"alg" (Algorithm) Header Parameter not allowed');if(i){if("string"!=typeof e.payload)throw new s("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new s("JWS Payload must be a string or an Uint8Array instance");"function"==typeof t&&(t=await t(o,e)),((e,t)=>{if(e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||e.match(/^A\d{3}(?:GCM)KW$/)){if(t instanceof Uint8Array||"secret"===t.type)return;throw new TypeError('CryptoKey or KeyObject instances for symmetric algorithms must be of type "secret"')}if(t instanceof Uint8Array)throw new TypeError("CryptoKey or KeyObject instances must be used for asymmetric algorithms");if("secret"===t.type)throw new TypeError('CryptoKey or KeyObject instances for asymmetric algorithms must not be of type "secret"')})(d,t);const u=function(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let a=0;return e.forEach((e=>{r.set(e,a),a+=e.length})),r}(y.encode(null!==(n=e.protected)&&void 0!==n?n:""),y.encode("."),"string"==typeof e.payload?y.encode(e.payload):e.payload),p=w(e.signature);if(!await g(d,t,p,u))throw new h;let m;m=i?w(e.payload):"string"==typeof e.payload?y.encode(e.payload):e.payload;const A={payload:m};return void 0!==e.protected&&(A.protectedHeader=o),void 0!==e.header&&(A.unprotectedHeader=e.header),A};const P=async e=>{var t,r;const{algorithm:n,keyUsages:o}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:{name:`SHA-${e.alg.substr(-3)}`}},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new a(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new a('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:{name:`SHA-${e.alg.substr(-3)}`}},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:{name:`SHA-${e.alg.substr(-3)}`}},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:{name:`SHA-${parseInt(e.alg.substr(-3),10)||1}`}},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new a('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":case"ES384":case"ES512":t={name:"ECDSA",namedCurve:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new a('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;default:throw new a('unsupported or invalid JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e);let s="jwk",c={...e};return delete c.alg,"PBKDF2"===n.name&&(s="raw",c=w(e.k)),A.subtle.importKey(s,c,n,null!==(t=e.ext)&&void 0!==t&&t,null!==(r=e.key_ops)&&void 0!==r?r:o)};const H=Object.freeze({verify:(e,t)=>new Promise(((r,n)=>{(async function(e,t,r){if(!f(e))throw new TypeError("JWK must be an object");if(t||(t=e.alg),"string"!=typeof t||!t)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?P({...e,alg:t,ext:!1}):w(e.k);case"RSA":if(void 0!==e.oth)throw new a('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return P({...e,alg:t});default:throw new a('unsupported "kty" (Key Type) Parameter value')}})(t).then((t=>async function(e,t,r){if(e instanceof Uint8Array&&(e=S.decode(e)),"string"!=typeof e)throw new s("Compact JWS must be a string or Uint8Array");const{0:a,1:n,2:o,length:c}=e.split(".");if(3!==c)throw new s("Invalid Compact JWS");const i=await v({payload:n||void 0,protected:a||void 0,signature:o||void 0},t,r);return{payload:i.payload,protectedHeader:i.protectedHeader}}(e,t))).then((()=>r(!0))).catch((e=>n(e)))}))});window.JWSVerifier=H})();